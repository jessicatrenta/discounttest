import { Conditions, ConditionalStyle } from './types';
declare type ChainableConditionalStyle<T, AcceptedConditions = Conditions> = ConditionalStyle<T, AcceptedConditions> & {
    when: typeof when;
};
/**
 * Style is a helper for authoring conditional values for prop styles.
 * Write complex conditional styles based on one or more conditions (viewport
 * sizes and interactive states) in a concise and expressive way.
 */
export declare const Style: {
    /**
     * Sets an optional default value to use when no other condition is met.
     *
     * @param defaultValue The default value
     * @returns The chainable condition style
     */
    readonly default: (<T, AcceptedConditions = Conditions>(defaultValue: T) => ChainableConditionalStyle<T, AcceptedConditions>) & {
        clearCache: () => void;
    };
    /**
     * Adjusts the style based on different conditions. All conditions, expressed
     * as a literal object, must be met for the associated value to be applied.
     *
     * The `when` method can be chained together to build more complex styles.
     *
     * @param conditions The condition(s)
     * @param value The conditional value that can be applied if the conditions are met
     * @returns The chainable condition style
     */
    readonly when: typeof when & {
        clearCache: () => void;
    };
};
declare function when<T, AcceptedConditions = Conditions>(this: any, conditions: AcceptedConditions, value: T): ChainableConditionalStyle<T, AcceptedConditions>;
export declare function isConditionalStyle<T, AcceptedConditions = Conditions>(value?: any): value is ConditionalStyle<T, AcceptedConditions>;
export {};
//# sourceMappingURL=style.d.ts.map